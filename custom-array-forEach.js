// Напишите полифил для метода forEach
// arr.forEach(callback(currentValue[, index[, array]])) {
//   // todo something 
//}[, thisArg])


// Прежде чем приступить к выполнению, мы должны обозначить такие ключевые моменты, как:
// 1) Проверка на функцию колбек
// 2) Проверка на передачу thisArg
// 3) Проверка на null или undefined вместо массива в колбеке
// 4) Проверка на значения в этом массиве (если вдруг они пустые (undefined)), то не нужно их перебирать

let arr = [1, 2, 3];
arr[10] = 10; // 3

Array.prototype.myCustomForEach = function(cbFn, thisArg) {
  console.log(this);

  if (typeof cbFn !== 'function') { // 6
    throw new Error('Not a function');
  }

  if (this == null) {
    throw new Error('Array can not null or undefined'); // 2
  }

  let context = this;

  if (arguments.length > 1) { // 5
    context = thisArg
  }

  let o = Object(this); // 3

  for (let i = 0; i < o.length; i++) {
    if(i in o) { // 4
      cbFn.call(context, this[i], i, this); // 5
    }
  }


}

arr.myCustomForEach((item, index, array) => {
  console.log(item); 
}, ['str']) // 5


// Чтобы записать свой кастомный метод (чтобы все массивы могли пользоваться этим методом), то надо в Array.prototype.myCustomForEach

// this.length - this это и есть наш массив
// 2) проверка на null и undefined вместо массива, понятно, что на эти типы данных нельзя вызвать метод, но что если кто-то сделает call или apply c
// null или undefined. (Array.prototype.forEach2.call(null)) тогда эта проверка пригодится // но это сработает только в режиме "use strict"
// И вопрос? почему this == null - такая проверка? так как undefined == null - будет true, и как раз мы проверим
// 3) нативный forEach не итерируется по пустым не заданным элементам, которых нет let arr = [1, 2, 3]; arr[10] = 10 // [1, 2, 3, empty × 7, 10]
// вот эту реализацию в нашем кастомном полифиле  надо реализовать, как?
// мы можем наш Array превратить в настоящий объект - Object(...//что угодно//...) - эта конструкция превращает что-то в Object, для чего это? - 
// чтобы мы в последствии могли быстро проверить, какие у нас есть свойства, каких нет 
// let o = Object(this) - сделали из текущего массива - объект,(но по факту он и остался массивом) чтобы потом итерироваться по свойствам и смотреть, 
// какие свойства есть и каких нет. По факту мы можем оставить всё как есть, без трансформации в объект и проверять на undefined в цикле,
// но это просто тот стиль, в котором полифил используется в нативном варианте и других библиотеках
// 4) тут спрашиваем, есть этот индекс у объекта, если есть, то итерируемся. И вот таким образом итерация происходит только по существующим элементам
// 5) разберёмся с thisArg
// - в качестве thisArg по умолчанию (= undefined ), но при вызове колбека, то будет использоваться  this ( который и есть arr), 
// если мы хотим другой this - то мы можем передать в качестве аргумента, чтобы использовать в колбеке, тоесть проверяем, если переданных аргументов
// больше чем 1, то context = thisArg;
// 6) плюс проверка на существования функции колбека